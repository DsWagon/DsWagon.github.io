---
layout: post
title: Python-Basics
date: 2024-02-06
description: Python basics
tags: python basics code
categories: code
featured: true
toc:
  sidebar: left
---



## Les diff√©rents types natifs
Il existe plusieurs types natifs comme les cha√Ænes de caract√®res (qui sont en fait tout simplement du texte), les nombres et les bool√©ens (qui vont nous permettre de travailler par la suite avec des conditions).

Il existe d'autres types natifs qui peuvent √™tre construits √† partir de ces trois types de base.

üëâ On retrouve par exemple les listes et les tuples qui nous permettent de repr√©senter une s√©quence de diff√©rents √©l√©ments ([1, 2, 3, 4]).

üëâ Les types d'ensembles comme les sets et frozen set, qui permettent de r√©aliser des op√©rations d'union, de diff√©rences ou encore d'intersection

üëâ Les types de correspondances avec les dictionnaires, qui sont un autre moyen d'organiser des donn√©es avec un syst√®me de cl√©s et de valeurs.

Dans les prochaines parties, on va s'int√©resser aux types natifs de base que sont les cha√Ænes de caract√®res, les nombres et les bool√©ens.

Les autres types natifs que je viens d'√©noncer sont un peu plus complexes et disposent de formations qui leur sont enti√®rement d√©di√©s et ce ne sont finalement que des fa√ßons d'organiser et d'agencer dans d'autres structures ces trois types natifs de base que l'on va voir dans les prochaines parties.

---

## Les cha√Ænes de caract√®res
Une cha√Æne de caract√®res, c'est ce qu'on appelle commun√©ment du texte.

Elle peut contenir autant de caract√®res que n√©cessaire. On pourrait donc sans probl√®me stocker, par exemple, un livre entier dans une cha√Æne de caract√®res.

Il est √©galement possible de cr√©er des cha√Ænes de caract√®res vides sans que cela ne pose de probl√®me √† Python.

Une cha√Æne de caract√®res elle est d√©limit√©e par des guillemets. Ces guillemets peuvent √™tre simples ou doubles. Le guillemet simple, c'est l'√©quivalent de ce qu'on appelle en fran√ßais une apostrophe.

Quelques exemples de cha√Ænes de caract√®res

````markdown
```python
une_chaine_vide = ''
une_chaine_vide_guillemets_doubles = ""
lorem = "Lorem ipsum dolor sit amet..."
```
````

Personnellement, je vous conseille d'utiliser principalement des guillemets doubles. Pourquoi ? Eh bien, tout simplement parce qu'avec des guillemets simples, c'est assez emb√™tant si vous souhaitez mettre des apostrophes dans votre texte. Prenons l'exemple de cette cha√Æne de caract√®res d√©limit√©e par des guillemets doubles :

`phrase = "Je m'appelle Patrick"`
L'apostrophe du mot ¬´ m'appelle ¬ª ne pose ici pas de probl√®me, car notre cha√Æne de caract√®res est d√©finie avec des guillemets doubles. Si, par contre, je remplace les guillemets doubles par des guillemets simples, on se retrouve avec un probl√®me qui est indiqu√© par la coloration syntaxique :

`phrase = 'Je m'appelle Patrick'`
L'apostrophe du mot ¬´ m'appelle ¬ª met fin √† la cha√Æne de caract√®res qui est initi√©e avec le premier guillemet simple. Si vous essayez de faire ceci dans un interpr√©teur Python, vous aurez donc une erreur de syntaxe.

Une des solutions √† ce probl√®me, c'est d'utiliser un antislash. L'antislash permet en effet de faire ce qu'on appelle un √©chappement, c'est-√†-dire signifier √† un caract√®re qu'il ne doit pas √™tre utilis√© pour sa fonction premi√®re, dans ce cas-ci, d√©limiter une cha√Æne de caract√®res, mais qu'il doit tout simplement √™tre utilis√© comme un caract√®re textuel.

Si vous essayez ce code dans un interpr√©teur Python, vous n'aurez cette fois plus d'erreur et vous voyez que l'antislash ne se retrouve pas dans la cha√Æne de caract√®res affich√©e :

`phrase = 'Je m\'appelle Patrick'`
On a donc bien l'apostrophe qui se retrouve correctement au milieu de notre cha√Æne de caract√®res.

Mais la fa√ßon la plus simple de proc√©der reste donc d'utiliser des guillemets doubles. Vous pourrez ainsi ins√©rer des apostrophes dans votre cha√Æne de caract√®res sans vous soucier de devoir les √©chapper avec un antislash.

Le dernier type de cha√Æne de caract√®res que l'on peut cr√©er, c'est une cha√Æne de caract√®res qu'on appelle multiligne. Pour cela, il suffit d'utiliser trois guillemets au d√©but et √† la fin de la cha√Æne de caract√®res en question :

```python
instructions = """
1. Battre les oeufs
2. Mettre le sucre
3. Rajouter la cr√®me
4. ¬´ Attendez la cr√®me... ¬ª
"""
```

√Ä noter que l√† encore, vous pouvez tr√®s bien utiliser des guillemets simples √† la place des guillemets doubles. Et pour une cha√Æne de caract√®res multiligne, les apostrophes √† l'int√©rieur de votre texte ne posent pas de probl√®me.

Dernier point important √† aborder certains caract√®res sont interpr√©t√©s de fa√ßon particuli√®re lorsqu'ils sont pr√©c√©d√©s d'un antislash.

Par exemple, \n sera interpr√©t√© comme un retour √† la ligne :

```python
>>> print("Bonjour\nTout le monde")
Bonjour
Tout le monde
```
Et si vous souhaitez faire un c≈ìur, vous pouvez utiliser \u, suivi du num√©ro correspondant au symbole dans la base de donn√©es des caract√®res Unicode :

```python
>>> print("\u2764")
‚ù§
```

Pour √©viter que ces caract√®res soient interpr√©t√©s par Python, on peut utiliser ce qu'on appelle les ¬´ raw-string ¬ª, que l'on pourrait traduire en fran√ßais par ¬´ cha√Æne de caract√®res brute ¬ª.

√áa peut √™tre tr√®s pratique, par exemple quand vous travaillez avec des chemins de dossier, notamment sur Windows. Dans le cas du chemin de dossier suivant, on a un \t et un \n qui, par d√©faut, vont √™tre interpr√©t√©s comme une tabulation et un retour √† la ligne :

```python
>>> print("c:\dossiers\thibault\nouveautes")
c:\dossiers    hibault
nouveautes
```

Pour √©viter qu'il soit interpr√©t√©, il suffit de rajouter la lettre ¬´ r ¬ª devant les guillemets de la cha√Æne de caract√®res. Ainsi, la cha√Æne de caract√®res sera interpr√©t√©e de fa√ßon brute et \t et \n seront ins√©r√©s tel quel :

```python
>>> print(r"c:\dossiers\thibault\nouveautes")
c:\dossiers\thibault\nouveautes
```
Pour finir, voici donc une liste non exhaustive des caract√®res qui sont interpr√©t√©s de fa√ßon sp√©ciale par Python lorsqu'ils sont pr√©c√©d√©s d'un antislash. Il faudra donc porter attention aux cha√Ænes de caract√®res qui peuvent contenir ces suites de caract√®res et, le cas √©ch√©ant, envisager d'utiliser une cha√Æne de caract√®res brute en la pr√©c√©dant de la lettre r :

```python
\a üëâ caract√®re d'appel (BEL)
\b üëâ caract√®re de retour arri√®re
\f üëâ saut de page
\n üëâ retour √† la ligne
\r üëâ retour chariot
\t üëâ  tabulation horizontale
\v üëâ tabulation verticale
```

## Les nombres

Avec Python, on fait la distinction entre deux types de nombres que l'on va voir dans cette partie :

Les nombres entiers.
Les nombres d√©cimaux.
Les nombres entiers, c'est tout simplement des nombres qui n'ont pas de d√©cimales apr√®s la virgule. √áa peut √™tre bien entendu, des nombres positifs comme des nombres n√©gatifs.

Vous pouvez repr√©senter, gr√¢ce au nombre entier, des nombres tr√®s importants. La seule limite vraiment, c'est la m√©moire de votre ordinateur.

Depuis la version 3.6 de Python, il est √©galement possible de rendre plus facile la lecture des nombres entiers avec la possibilit√© d'ins√©rer des tirets du bas dans un nombre sans que cela ne cause d'erreur.

Vous pouvez placer ces tirets du bas o√π bon vous semble, mais g√©n√©ralement, on s'en sert pour s√©parer les milliers et rendre plus rapide l'identification d'un nombre.

```python
1000000
1_000_000
```

Le deuxi√®me type de nombres qu'on utilise, ce sont les nombres d√©cimaux que l'on appelle √©galement nombres flottants.

Ce sont tout simplement des nombres qui contiennent des d√©cimales apr√®s la virgule.

Pour d√©finir un nombre d√©cimal avec Python, on n'utilise pas la virgule, mais le point. Si vous utilisez une virgule √† la place du point, Python vous retournera une erreur.

L√† encore, les nombres peuvent √™tre positifs comme n√©gatifs. Et m√™me si le nombre apr√®s la virgule est z√©ro ce nombre sera tout de m√™me consid√©r√© par Python comme un nombre d√©cimal et ne sera donc pas converti en nombre entier.

```python
10.0  # 10.0 est un nombre d√©cimal
10    # 10 est un nombre entier
```
D√®s que vous avez un point √† l'int√©rieur d'un nombre, m√™me si les d√©cimales apr√®s le point sont z√©ro, ce nombre sera consid√©r√© comme un nombre d√©cimal et non plus comme un nombre entier.

## Les bool√©ens

Un bool√©en, c'est un objet qui ne peut prendre que deux valeurs : True et False, qui signifient vrai et faux.

Les bool√©ens sont des types natifs qui sont une sous-classe des nombres entiers. True et l'√©quivalent du nombre 1 et False l'√©quivalent du nombre 0.

Vous pouvez v√©rifier cette affirmation avec la fonction isinstance. On voit bien avec cette fonction que le type natif bool qui correspond aux bool√©ens est une sous-classe du type int qui repr√©sente les nombres entiers :

```python
>>> issubclass(bool, int)
True
```
On peut ainsi sans probl√®me additionner des bool√©ens avec des nombres :

```python
>>> True + 1
2
>>> False + 5
5
```

Pour l'instant, cela ne vous semble peut-√™tre pas tr√®s utile, mais je vous assure que dans certains cas bien pr√©cis, √ßa peut √™tre tr√®s int√©ressant.

Il faut savoir √©galement que tous les objets peuvent √™tre vrais ou faux. En anglais, on appelle √ßa des ¬´ truthy ¬ª ou ¬´ falsy ¬ª. Pour v√©rifier si un objet est vrai ou faux, on peut utiliser la fonction bool.

Vous pouvez lui passer n'importe quel objet, comme ici la cha√Æne de caract√®res "Bonjour" et la fonction bool vous retournera True ou False :

```python
>>> bool("Bonjour")
True
```
Dans ce cas-ci, la fonction bool retourne True, car la cha√Æne de caract√®res contient au moins un caract√®re.

Tous les objets ont une valeur qui, par d√©faut, est consid√©r√©e comme False et toutes les autres valeurs qui sont consid√©r√©es comme True.

Par exemple pour les cha√Ænes de caract√®res, seule une cha√Æne de caract√®res vide est consid√©r√©e comme fausse. D√®s que vous avez au moins un caract√®re, l'√©valuation de la cha√Æne de caract√®res avec la fonction bool est vraie :

```python
>>> bool("")
False
>>> bool("1")
True
>>> bool("Docstring")
True
```
Pour les nombres, que ce soient les nombres entiers ou d√©cimaux, c'est la valeur de z√©ro qui est consid√©r√©e comme fausse. Toutes les autres valeurs, que ce soit un nombre n√©gatif ou positif, sont consid√©r√©es comme vraies :

```python
>>> bool(0)
False
>>> bool(0.0)
False
>>> bool(1)
True
>>> bool(-1)
True
>>> bool(287)
True
```
Pour les types s√©quentiels comme les listes ou les dictionnaires, ils sont consid√©r√©s comme faux s'ils sont vides. D√®s qu'ils contiennent au moins un √©l√©ment, ils sont consid√©r√©s comme vrais :

```python
>>> bool([])  # liste
False
>>> bool(())  # tuple
False
>>> bool({})  # dictionnaire
False
>>> bool([0])
True
>>> bool((0, 255, 255))
True
```
Les bool√©ens, quand on voit √ßa tout seul, √ßa ne semble pas avoir beaucoup d'importance. C'est vraiment lorsque vous allez commencer √† utiliser des conditions et √† cr√©er des expressions plus complexes qui pourront √™tre √©valu√©es comme vraies ou fausses, que vous verrez leur vraie utilit√©.

## Les constructeurs de types natifs

Avec Python, tous les types natifs de base peuvent √™tre cr√©√©s directement √† partir de leur classe correspondante.

Il y a la classe str pour les cha√Ænes de caract√®res, int pour les nombres entiers, float pour les nombres d√©cimaux et bool pour les bool√©ens. Ce sont des termes que vous retrouverez tr√®s souvent en anglais dans la documentation officielle de Python.

Le nom des classes est cependant raccourci. Les mots entiers en anglais sont string pour cha√Æne de caract√®res, integer pour les nombres entiers, float pour les nombres d√©cimaux et boolean pour les bool√©ens.

Tous les objets correspondant aux types natifs de base pourraient ainsi √™tre cr√©√©s avec ces classes.

```python
>>> str("bonjour")
'bonjour'
>>> int(5)
5
>>> float(10.7)
10.7
>>> bool(True)
True
```
Cependant, ce n'est pas tr√®s utile, car Python est suffisamment intelligent pour d√©terminer le type des objets, gr√¢ce par exemple aux guillemets pour les cha√Ænes de caract√®res, ou au point de la d√©cimale pour les nombres d√©cimaux.

Quand on cr√©e ces objets, on peut donc directement les √©crire comme ceci.

```python
>>> "bonjour"
'bonjour'
>>> 5
5
>>> 10.7
10.7
>>> True
True
```
Ces classes sont √©galement appel√©es des fonctions de conversion. Bien qu'elles puissent ressembler √† des fonctions, ce sont dans les faits des classes. Mais l√† o√π elles ont un vrai int√©r√™t, c'est qu'elles peuvent √™tre utilis√©es pour convertir des objets d'un type √† un autre.

Par exemple, vous pouvez convertir un nombre entier en cha√Æne de caract√®res en utilisant la classe str. Le r√©sultat de l'utilisation de cette classe avec le nombre entier 5 nous donnera la cha√Æne de caract√®res "5".

```python
>>> str(5)
'5'
```
On a donc effectu√© une conversion d'un nombre entier en cha√Æne de caract√®res.

Si on veut √™tre tr√®s pr√©cis, on ne fait pas vraiment une conversion. Concr√®tement, on cr√©e un nouvel objet de type cha√Æne de caract√®res √† partir du nombre entier 5. Mais dans les faits, c'est un peu comme si on convertissait un objet d'un type √† un autre. C'est pour √ßa que vous retrouverez souvent ces classes sous le nom de fonctions de conversion.

√Ä l'inverse, la classe int peut √™tre utilis√©e pour convertir une cha√Æne de caract√®res qui contient un nombre, ou si vous pr√©f√©rez pour cr√©er un nouvel objet de type nombre entier, √† partir de la cha√Æne de caract√®res "2".

```python
>>> int("2")
2
```
Il faut cependant faire attention, car on peut parfois avoir des erreurs en essayant de cr√©er des objets √† partir de donn√©es que Python n'arrive pas √† convertir.

Si vous essayez par exemple, de convertir la cha√Æne de caract√®res "bonjour" en nombre, avec la classe int, vous obtiendrez une erreur car Python ne sait pas comment convertir ce mot en nombre entier.

```python
>>> int("bonjour")
ValueError: invalid literal for int() with base 10: 'bonjour'
```
Et c'est assez logique, car il est difficile d'exprimer le mot bonjour sous la forme d'un nombre.

test
test
test
test
bordel
